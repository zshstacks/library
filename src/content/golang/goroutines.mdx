---
title: Goroutines & Channels
description: Core concurrency primitives in Go — how goroutines are scheduled and when to reach for channels vs mutexes.
tags: [concurrency, goroutines, channels]

---

## What is a goroutine?

A goroutine is a lightweight thread managed by the Go runtime. Unlike OS threads,
goroutines are multiplexed onto a small number of OS threads — you can have
thousands running concurrently without blowing memory.

```go
go func() {
    fmt.Println("running concurrently")
}()
```

The `go` keyword is all it takes. The function runs in a new goroutine immediately.

## Channels

Channels let goroutines communicate and synchronise. Think of them as typed pipes —
send a value in one end, receive it from the other.

```go
ch := make(chan int)

go func() {
    ch <- 42  // send
}()

value := <-ch // receive (blocks until something is sent)
fmt.Println(value) // 42
```

<Callout type="tip">
    Rule of thumb: use channels when **transferring ownership** of data between
    goroutines, use `sync.Mutex` when **guarding shared state** that multiple
    goroutines read/write.
</Callout>

### Buffered channels

A buffered channel has capacity. Sends only block when the buffer is full,
receives only block when it's empty.

```go
ch := make(chan int, 3) // buffer holds 3 ints

ch <- 1 // doesn't block
ch <- 2 // doesn't block
ch <- 3 // doesn't block
ch <- 4 // blocks — buffer full
```

## The select statement

`select` lets a goroutine wait on multiple channel operations at once,
proceeding with whichever is ready first.

```go
select {
case msg := <-ch1:
    fmt.Println("from ch1:", msg)
case msg := <-ch2:
    fmt.Println("from ch2:", msg)
case <-time.After(1 * time.Second):
    fmt.Println("timed out")
}
```

Add a `default` case to make it non-blocking.

## Common patterns

| Pattern | When to use |
|---------|-------------|
| Done channel | Signal goroutines to stop |
| Fan-out | Distribute work across N workers |
| Fan-in | Merge N channels into one |
| Timeout | `time.After` inside `select` |
| Pipeline | Chain stages, each a goroutine |

<Callout type="warning">
    Always make sure every goroutine you launch can exit. Goroutine leaks are
    one of the most common Go performance bugs — use done channels or
    `context.Context` for cancellation.
</Callout>